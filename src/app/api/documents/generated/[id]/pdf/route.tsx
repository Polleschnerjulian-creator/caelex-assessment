/**
 * PDF Export for Generated Documents
 *
 * POST /api/documents/generated/[id]/pdf
 *
 * Uses the same BaseReport template as all other working PDF routes.
 */

import React from "react";
import { NextResponse } from "next/server";
import { auth } from "@/lib/auth";
import { prisma } from "@/lib/prisma";
import { renderToBuffer } from "@react-pdf/renderer";
import { BaseReport } from "@/lib/pdf/templates/base-report";
import type {
  ReportConfig,
  ReportSection,
  ReportSectionContent,
} from "@/lib/pdf/types";

export const maxDuration = 60;

// ─── Deep sanitizer: convert DB Json back to strict ReportSectionContent ───

function str(v: unknown): string {
  if (v == null) return "";
  if (typeof v === "string") return v;
  if (typeof v === "number" || typeof v === "boolean") return String(v);
  try {
    return JSON.stringify(v);
  } catch {
    return "";
  }
}

function sanitizeContent(raw: unknown): ReportSectionContent | null {
  if (!raw || typeof raw !== "object") return null;
  const block = raw as Record<string, unknown>;
  if (typeof block.type !== "string") return null;

  switch (block.type) {
    case "text":
      return { type: "text", value: str(block.value) };

    case "heading":
      return {
        type: "heading",
        value: str(block.value),
        level: block.level === 1 ? 1 : block.level === 3 ? 3 : 2,
      };

    case "list": {
      const items = Array.isArray(block.items)
        ? block.items.map((item: unknown) => str(item))
        : [];
      return {
        type: "list",
        items,
        ordered: block.ordered === true,
      };
    }

    case "table": {
      const headers = Array.isArray(block.headers)
        ? block.headers.map((h: unknown) => str(h))
        : [];
      const rows = Array.isArray(block.rows)
        ? block.rows
            .filter((r: unknown) => Array.isArray(r))
            .map((row: unknown[]) => row.map((cell: unknown) => str(cell)))
        : [];
      return { type: "table", headers, rows };
    }

    case "keyValue": {
      const items = Array.isArray(block.items)
        ? block.items
            .filter((it: unknown) => it != null && typeof it === "object")
            .map((it: unknown) => {
              const item = it as Record<string, unknown>;
              return { key: str(item.key), value: str(item.value) };
            })
        : [];
      return { type: "keyValue", items };
    }

    case "alert": {
      const severity =
        block.severity === "warning"
          ? "warning"
          : block.severity === "error"
            ? "error"
            : "info";
      return {
        type: "alert",
        severity: severity as "info" | "warning" | "error",
        message: str(block.message),
      };
    }

    case "divider":
      return { type: "divider" };

    case "spacer":
      return {
        type: "spacer",
        height: typeof block.height === "number" ? block.height : 16,
      };

    default:
      return null;
  }
}

function sanitizeSections(raw: unknown): ReportSection[] {
  if (!Array.isArray(raw)) return [];
  return raw
    .filter(
      (s): s is Record<string, unknown> => s != null && typeof s === "object",
    )
    .map((sec) => ({
      title: str(sec.title),
      content: (Array.isArray(sec.content) ? sec.content : [])
        .map((c: unknown) => sanitizeContent(c))
        .filter((c): c is ReportSectionContent => c !== null),
    }));
}

// ─── Route Handler ───

export async function POST(
  _req: Request,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { id } = await params;

    const doc = await prisma.generatedDocument.findFirst({
      where: { id, userId: session.user.id, status: "COMPLETED" },
    });

    if (!doc) {
      return NextResponse.json(
        { error: "Document not found or not yet completed" },
        { status: 404 },
      );
    }

    const rawSections =
      doc.isEdited && doc.editedContent ? doc.editedContent : doc.content;

    const sections = sanitizeSections(rawSections);

    if (sections.length === 0) {
      return NextResponse.json(
        { error: "No content available for PDF generation" },
        { status: 400 },
      );
    }

    // Build ReportConfig — same pattern as all working PDF routes
    const config: ReportConfig = {
      metadata: {
        reportId: doc.id,
        reportType: "compliance_certificate",
        title: doc.title,
        generatedAt: new Date(),
        generatedBy: "ASTRA AI",
        organization: "Caelex",
      },
      header: {
        title: doc.title,
        subtitle: `Generated by ASTRA AI — ${new Date().toLocaleDateString("en-GB")}`,
        date: new Date(),
        logo: true,
      },
      footer: {
        pageNumbers: true,
        confidentialityNotice: "CONFIDENTIAL",
        disclaimer: "For informational purposes only — not legal advice",
      },
      sections,
    };

    // Render PDF using BaseReport — exact same component used by all working routes
    const pdfBuffer = await renderToBuffer(<BaseReport config={config} />);

    // Update document record
    await prisma.generatedDocument.update({
      where: { id },
      data: {
        pdfGenerated: true,
        pdfGeneratedAt: new Date(),
      },
    });

    const filename = doc.title.replace(/[^a-zA-Z0-9-_ ]/g, "");

    return new NextResponse(new Uint8Array(pdfBuffer), {
      headers: {
        "Content-Type": "application/pdf",
        "Content-Disposition": `attachment; filename="${filename}.pdf"`,
        "Cache-Control": "no-store",
      },
    });
  } catch (error) {
    console.error("PDF generation error:", error);
    const message =
      error instanceof Error ? error.message : "PDF generation failed";
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
